\documentclass[11pt]{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage[final]{graphicx}
\graphicspath{{./project_structure.pdf}}
\usepackage{xurl}
\usepackage{float}

\usepackage{fontspec}
\newfontfamily{\lean}[Scale=MatchLowercase]{Consolas}
\newfontfamily{\ftl}[Scale=MatchLowercase]{DejaVuSansMono}

\usepackage{listings}
\lstdefinestyle{lean}{
    basicstyle=\lean\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=10pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    breakindent=0pt,
    frame=trbl,
    frameround=tttt,
    framesep=3pt,
}
\lstdefinestyle{ftl}{
    language={ForTheL},    
    basicstyle=\ftl\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=10pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    breakindent=0pt,
    frame=trbl,
    frameround=tttt,
    framesep=3pt,
}
\lstdefinelanguage{ForTheL}{
  keywords=[1]{Signature, Axiom, Theorem, Definition},
  keywords=[2]{Proof, End, qed, by},
  keywords=[3]{Assume, Let, us, show, Since, we, have},
% Defining keywords that contain blank spaces seems to be very inconvenient. Therefore "us" and "show" are individual keywords, "Let" must have the same color everywhere and "that" can not be higlighted as a keyword, because that would also show up at wrong places.
  sensitive=false,
  morecomment=[l]{\#},
  morestring=[s]{[read}{]},
  morestring=[s]{[synonym}{]},
  commentstyle={\color{commentColor}},
  stringstyle={\color{readColor}},
  keywordstyle=[1]{\color{signatureColor}},
  keywordstyle=[2]{\color{proofColor}},
  keywordstyle=[3]{\color{assumeColor}},
}

\usepackage{color}
\definecolor{commentColor}{RGB}{204,0,0}
\definecolor{readColor}{RGB}{255,132,0}
\definecolor{signatureColor}{RGB}{0,102,153}
\definecolor{proofColor}{RGB}{0,153,255}
\definecolor{assumeColor}{RGB}{0,153,102}

\author{Erik Sturzenhecker, Felix Thiele}
\title{A Start to the formalization of Linear Algebra in ForTheL}
\date{\today}


\begin{document}
\maketitle
\newpage 
\setcounter{tocdepth}{10}
\tableofcontents

\newpage 
\section{Introduction}
\subsection{Naproche}
In this project we build a linear algebra library in ForTheL with Naproche-SAD. ForTheL, which stands for Formal Theory Language, is a language that comes close to human language. This reduces many of the initial hurdles people encounter in the formalization of mathematics. Naproche can not only interpret ForTheL code, but is also backed with a strong Automated Theorem Prover, to which we shall refer to as e-prover. This makes many Proofs in our library easier, since some trivial steps can be skipped. At the same time this comes with massive performance issues, since checking this small library is a comparably very time intensive task.

\subsection{Results}
Some of the results given in this library are:
\newline
The \textbf{definitions} of:
\begin{itemize}[nolistsep, noitemsep]
\item Groups, Rings, Fields
\item Vector spaces, Subspaces, Dual spaces
\item Homomorphisms, Endomorphisms, Automorphisms of vector spaces
\item Lists, Linear independence
\end{itemize}
And the \textbf{proofs} of:
\begin{itemize}[nolistsep, noitemsep]
\item A field is a vector space over itself.
\item The linear maps between $K$-vector spaces $VÂ§$ and $W$ form a vector space Hom($K$,$V$,$W$).
\item If $f$ is linear, Ker($f$) is a subspace.
\item If $f$ is linear and Ker($f$) $=$ \{0\}, then $f$ is injective.
\item Any $K$-vector space $V$ can be embedded into the double dual space $(V^{*})^{*}$
\item The endomorphisms of a $K$-vector space $V$ form a ring End($K$,$V$).
\item The invertible elements of a ring form a multiplicative group.
\end{itemize}


\newpage
\lstset{style=lean}
\section{The Lean File}
For inspiration on how to formalize linear algebra for a proof checker we looked into the file "vector\_space.lean" found under \url{https://github.com/kckennylau/Lean/blob/master/linear_algebra/vector_space.lean}. It is part of a small lean library by Kenny Lau containing formalizations of various mathematical topics. Lean is a theorem prover and a programming language based on dependent type theory. There is an extensive library of mathematical lean texts, the mathlib (\url{https://github.com/leanprover-community/mathlib}), maintained by lean users, which is used and build upon in vector\_space.lean.



\subsection{Mathematical Content}
The file vector\_space.lean covers the following definitions and statements of linear algebra:
\begin{itemize}
\item {\lean field.to\_vector\_space}: Any field is a vector space over itself.
\item {\lean sub\_vector\_space}: Definition of a vector subsace. Definition and proof of the vector space structure on it.
\item {\lean linear\_space K V W}: Definition of the set of linear maps between two $K$-vector spaces $V$ and $W$. Easy proofs about linear maps.
\item {\lean ker}: Definition of the kernel of a linear map. Some small proofs.
\item Definition and proof of the vector space structure on {\lean linear\_space K V W}.
\item Definition of the dual vector space.
\item Definition and proof of the ring structure on {\lean linear\_space K V V} by taking the function composition as multiplication.
\item {\lean invertible K V}: Definition and proof of the (general linear) group structure on the invertible elements of {\lean linear\_space K V V}
\end{itemize}



\subsection{Characteristic Features}
The notions above are defined in the canonical way and the proofs are of course trivial from an algebraic standpoint. Thus, there is no need for huge lambda terms (which are otherwise not uncommon in lean texts) and the code is fairly easy to understand.
- using the following notions from the mathilb: ... \\
- type classes: has\_add, has\_zero, etc. \\
- @[simp] (-> easy statements named above)\\
- ...



\subsection{Adjusting the Code}
The latest version of vector\_space.lean is from November 2017. Since then, it seems that the mathlib has developed to a point where it became incompatible with vector\_space.lean.
However, slight adjustments in the file made it work with the current version of the mathlib. This comprises the following changes:
\begin{itemize}
\item bla
\item blub
\end{itemize}



\newpage
\lstset{style=ftl}
\section{Formalization in ForTheL}
\subsection{Project Structure}
Giving the project a treelike structure with a file to each topic ensures increased readability and scalability. 
In contrast to having one large file building up mathematics, this enables us to pick what files need to be imported to each file. 
Our structure is depicted in the graph below.

\begin{figure}[h]
\begin{center}
\makebox[\linewidth][c]{
\includegraphics[scale=0.75]{./project_structure.pdf}
}
\end{center}
\end{figure}

\newpage

The e-prover is not fast enough to compile the entire library with all proofs in reasonable time. 
Instead, for every file we introduce two new files inserting "A\_" and "P\_" respectively in front of the file names. We insert "D\_" before our original file. This gives us an Axiom, Proof and Definition file. 
The Definition file holds all the definitions of the given topic. 
The Proof file holds the theorems and their proofs. The Axiom file holds all the statements of the Proof file in axiomatized form. 
The Proof and Axiom files only read their corresponding Definition file, while Definition files read the Axiom files of all the topics they are building upon. 
This ensures a fast compilation since we don't need to reprove proven statements. 
This file reading structure is depicted below.

\begin{figure}[h]
\begin{center}
\makebox[\linewidth][c]{
\includegraphics[scale=0.75]{./project_structure_explained.pdf}
}
\end{center}
\end{figure}

Additionally, it can sometimes be helpful to split the P\_ files even more, especially when more multiple theorems are supposed to follow on a single D\_ file. In our case, P\_vector\_space contained five (partly independent) theorems, each needing some lemmata. Reasoning and ontological checking of the proofs became considerably slower when the respective theorem was preceded by other lemmata and theorems. The solution was to write four different proof files (P\_vector\_space\_1, \_2, \_3 and \_4), each starting with only the required statements of the preceding proof files - in axiomatized form.


\subsection{The Implementation}

\subsubsection{Sets and Functions}

Our D\_ Set and D\_ Function files our kept very lightweight and only include key statements. This is due to both files being so close to the root node of the library graph. Adding more definitions will substantially slow down the e-prover in all following files.

\subsubsection{Algebraic Structures}
Many of the objects we examine in this library have a similar structure. For example abelian groups, fields, vector spaces and rings all have a carrier, a zero element, and an addition operation. We introduce an object called structure in 002D\_structure.ftl.

\begin{lstlisting}
Signature. lang is a set.
Axiom. lang = {carr,zero,one,add,mul,neg,inv,smul}.
Definition. A structure is a function S such that Dom(S) is subset of lang.
\end{lstlisting}

We can now define a each of the linear algebra structures above as a structure with the necessary components of {\ftl lang} in its domain. This allows for easy expansions of these structures one example of which we shall see in the section about Field2VS. Now we define the following abbreviations:

\begin{lstlisting}
Let S denote a structure.
Let |S| stand for S[carr].
Let 0{S} stand for S[zero].
Let 1{S} stand for S[one].
Let add{S} stand for S[add].
Let mul{S} stand for S[mul].
Let neg{S} stand for S[neg].
Let inv{S} stand for S[inv].
Let smul{S} stand for S[smul].

Let a +{S} b stand for add{S}[(a,b)].
Let a *{S} b stand for mul{S}[(a,b)].
Let ~{S} a stand for neg{S}[a].
Let a -{S} b stand for add{S}[(a,neg{S}[b])].
Let a /{S} b stand for mul{S}[(a,inv{S}[b])].
Let a @{S} b stand for smul{S}[(a,b)].
Let a < S stand for a << |S|.
Let a < S* stand for a << |S|\{0{S}}.
\end{lstlisting}

\newpage
As an example, this is our definition of an abelian group:
\begin{lstlisting}
Definition. An abelian group is a structure G such that
     (carr,zero,add,neg << Dom(G))
 and (|G| is a set)
 and (0{G} < G)
 and (add{G} is a function from Prod(|G|,|G|) to |G|)
 and (neg{G} is a function from |G| to |G|)
 and (for all a < G     :       a +{G} 0{G} = a)
 and (for all a < G     :          a -{G} a = 0{G})
 and (for all a,b,c < G : a +{G} (b +{G} c) = (a +{G} b) +{G} c)
 and (for all a,b < G   :          a +{G} b = b +{G} a). 
\end{lstlisting}


\subsubsection{Homomorphisms}

After the definition of various structures on sets we define homomorphisms. These require quite an extensive preparation which is done in the func\_ files, defining the zero, addition, negation, and scalar multiplication on Hom(K,V,W). These are split from the D\_homomorphisms file because the corresponding P\_ files hold long proofs which become easier to check.

For brevity in D\_ func\_ zero we introduce the following abbreviations:

\begin{lstlisting}
Let 2Vectorspace(K,V,W) stand for
(K is a field and (V is a vector space over K) and (W is a vector space over K)).
\end{lstlisting}


\subsubsection{Field2VS}
Proving that a field is a vector space becomes easier through the structure construction. We don't have to 
redefine the part of the structure that already exists but can instead just add scalar multiplication to
the field. This done in the following way:

\begin{lstlisting}
Let K denote a field.
Axiom. (K has smul).
Axiom. smul{K} = mul{K}.
\end{lstlisting}

We then prove in the the P\_ field2VS file that this really does create a vector space as follows.
\newpage
\begin{lstlisting}
Theorem. Let K be a field. Then K is a vector space over K.
Proof.
 carr,zero,add,neg,smul << Dom(K).
 K is an abelian group.
 smul{K} is a function from Prod(|K|,|K|) to |K|.
 For all u < K                 :       1{K} @{K} u = u.
 For all a,b < K for all v < K : (a *{K} b) @{K} v = a @{K} (b @{K} v).
 For all a,b < K for all v < K : (a +{K} b) @{K} v = (a @{K} v) +{K} (b @{K} v).
 For all a < K for all v,w < K : a @{K} (v +{K} w) = (a @{K} v) +{K} (a @{K} w).
qed.
\end{lstlisting}

\subsubsection{Lists}

A list is defined as function from a set to a structure with a carrier and a zero element. The zero element ensures, that the list is not defined over an empty set of objects. 

\subsection{Experiences}
\subsubsection{Functional Approach to Algebraic Structures} \label{functionalapproach}

\subsubsection{Instability regarding Changes in the Preliminaries}

\subsubsection{Other Experiences}


\newpage
\section{Comparison of Lean and Naproche/ForTheL}


\newpage 
\section{Next Steps in Naproche and ForTheL}

It seems like this project has hit somewhat of a ceiling in what Naproche is capable of. 
Even small changes in beginning files can massively impact the check times of files further down the project graph.
While the main problem that needs to be addressed is a more efficient structuring and analysis of the cache, we propose the following ideas to improve the writing experience.

Firstly Naproche needs an increased transparency in what the e-prover is doing. On the one hand the e-prover is a huge blessing, simplifying many steps. On the other hand it is the source of many problems, since the mathematician can not guess where the e-prover gets stuck. Also, the e-prover will often take longer or even can't compile working code, if it is copied to a later part of the file. This is probably due to the increased breadth of the internal search tree. To counter these effects, while keeping the luxury of an assisting e-prover, we suggest the e-prover return the proofs of each statement, which can then be either pasted into the code or be saved in a separate file. This decoupling of the e-prover to the checking process will not only save time, but also guarantee more stability.

ForTheL has a 
\begin{lstlisting}
Let us show statementX.
reasoning
end.
\end{lstlisting} 
functionality, to clean up the proof structure. We recommend adding a similar functionality
\begin{lstlisting}
Since 
reasoning
we have statementX.
\end{lstlisting} 
that is only for ontological reasoning. In this project we find that these parts of the proofs make up for an extensive part of our code. This leads to less readability, since these parts are mostly superfluous from a human point of view.

Additionally to this, we think ForTheL would greatly benefit from code sectioning functionality. This would not only improve code transparency but also speed up checking times. At the moment the e-prover can only be restricted by 
\begin{lstlisting}
statementX (by theoremY).
\end{lstlisting}  commands. Introducing code sections will allow broader restrictions.

At the moment, functions and sets are hard coded into the naproche system. Bigger projects will require more transparency in precisely what is axiomatized and how these basic notions are defined. The observations described in \ref{functionalapproach} suggest a built-in support for polyadic functions.

\end{document}

